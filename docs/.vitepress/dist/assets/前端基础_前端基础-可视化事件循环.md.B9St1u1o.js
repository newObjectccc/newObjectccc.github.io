import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.nQaBHiNx.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端基础/前端基础-可视化事件循环.md","filePath":"前端基础/前端基础-可视化事件循环.md"}'),t={name:"前端基础/前端基础-可视化事件循环.md"},o=e(`<h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h2 id="✨♻️-可视化事件循环" tabindex="-1">✨♻️ 可视化事件循环 <a class="header-anchor" href="#✨♻️-可视化事件循环" aria-label="Permalink to &quot;✨♻️ 可视化事件循环&quot;">​</a></h2><p>这是一篇我自己翻译的前端基础博文，原作者是Lydia Hallie。 想看原文的小伙伴可以直接转到 <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" target="_blank" rel="noreferrer">✨♻️ JavaScript Visualized: Event Loop</a></p><p>here we go！</p><h3 id="正文开始👉" tabindex="-1">正文开始👉 <a class="header-anchor" href="#正文开始👉" aria-label="Permalink to &quot;正文开始👉&quot;">​</a></h3><hr><h4 id="✨♻️javascript-可视化-事件循环-event-loop" tabindex="-1">✨♻️JavaScript 可视化: 事件循环（Event Loop） <a class="header-anchor" href="#✨♻️javascript-可视化-事件循环-event-loop" aria-label="Permalink to &quot;✨♻️JavaScript 可视化: 事件循环（Event Loop）&quot;">​</a></h4><p>事件循环是那种每个<code>JavaScript</code>开发人员都必须以某种方式应对的事物之一，但一开始可能有点难以理解。作为一个视觉学习者，我想通过以低分辨率的<code>gif</code>形式向你解释它，因为现在是2019年，<code>gif</code>还是有些像素化和模糊。</p><p>但首先，什么是事件循环，为什么你应该关注它？</p><p><code>JavaScript</code>是单线程的：一次只能运行一个任务。通常这没什么大不了的，但想象一下你正在运行一个需要30秒的任务...是的...在这个任务期间，我们需要等待30秒才能进行其他任何操作（<code>JavaScript</code>默认在浏览器的主线程上运行，因此整个UI都会被挂起）😬 这是2019年了，没有人想要一个慢速且无响应的网站。</p><p>幸运的是，浏览器给了我们一些<code>JavaScript</code>引擎自身没有提供的功能：<code>Web API</code>。这包括<code>DOM</code> <code>API</code>、<code>setTimeout</code>、<code>HTTP</code>请求等等。这可以帮助我们创建一些异步、非阻塞的行为🚀</p><p>当我们调用一个函数时，它会被添加到一个叫做调用栈的地方。调用栈是JS引擎的一部分，这不是与特定浏览器相关的概念。它是一个栈，意味着它是先进后出的（想象一堆煎饼）。当一个函数返回一个值时，它会从栈中弹出👋</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop1.gif" alt="1"></p><p><code>respond</code> 函数返回一个 <code>setTimeout</code> 函数。<code>setTimeout</code> 由Web API提供，它允许我们延迟任务而不会阻塞主线程。我们传递给 <code>setTimeout</code> 函数的回调函数，箭头函数 <code>() =&gt; { 返回 &#39;Hey&#39; }</code> 被添加到Web API中。同时，<code>setTimeout</code> 函数和 <code>respond</code> 函数从栈中弹出，它们都已经返回了它们的值！</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop2.gif" alt="2"></p><p>在Web API中，一个定时器会运行我们传递给它的第二个参数指定的时间长度，比如<code>1000</code>毫秒。回调函数不会立即被添加到调用栈，而是被传递给一个称为&quot;队列&quot;的东西。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop3.gif" alt="3"></p><p>这可能是一个令人困惑的部分：这并不意味着在<code>1000</code>毫秒后回调函数被添加到调用栈（从而返回一个值）！它只是在<code>1000</code>毫秒后被添加到队列中。但是队列是一个队列，函数必须等待它的轮到！</p><p>现在，这是我们一直在等待的部分... 事件循环该做它唯一的任务了：连接队列和调用栈！如果调用栈为空，也就是说之前调用的所有函数都已经返回了值并从调用栈中弹出，那么队列中的第一个项会被添加到调用栈中。在这种情况下，没有其他函数被调用，这意味着在回调函数成为队列中的第一个项时，调用栈为空。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop4.gif" alt="4"></p><p>回调函数被添加到调用栈中，被调用并返回一个值，然后从栈中弹出。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop5.gif" alt="5"></p><p>阅读文章是有趣的，但只有通过不断地实际应用和实践，才能真正对此感到舒适。尝试弄清楚如果我们运行以下代码会打印什么到控制台：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;First&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Second&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> baz</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Third&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>明白了吗？让我们快速看一下在浏览器中运行这段代码时发生了什么：</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/loop6.gif" alt="6"></p><ol><li>我们调用 <code>bar</code> 函数。<code>bar</code> 函数返回一个 <code>setTimeout</code> 函数。</li><li>我们传递给 <code>setTimeout</code> 的回调函数被添加到Web API中，<code>setTimeout</code> 函数和 <code>bar</code> 函数从调用栈中弹出。</li><li>定时器运行，在此期间调用了 <code>foo</code> 函数并打印了&quot;First&quot;。<code>foo</code> 函数返回(<code>undefined</code>)，随后 <code>baz</code> 函数被调用，回调函数被添加到队列中。</li><li><code>baz</code> 函数打印了&quot;Third&quot;。事件循环在 <code>baz</code> 函数返回后发现调用栈为空，随后将回调函数添加到调用栈中。</li><li>回调函数打印了&quot;Second&quot;。</li></ol><p>希望这篇文章能让你对事件循环更加舒适！如果仍然感到困惑，不用担心，最重要的是理解某些错误/行为可能出现的原因，以便有效地搜索正确的术语，并找到正确的 <code>Stack Overflow</code> 页面 💪🏼 如果有任何问题，请随时向我提问！</p><hr><p>😊okk~ 翻译完了，纯人工翻译，希望能够帮到各位，如有纰漏，欢迎指正~</p>`,30),p=[o];function n(h,l,c,d,k,r){return a(),i("div",null,p)}const y=s(t,[["render",n]]);export{E as __pageData,y as default};
