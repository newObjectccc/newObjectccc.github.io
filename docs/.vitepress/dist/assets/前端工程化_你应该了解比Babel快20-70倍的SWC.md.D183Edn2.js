import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.nQaBHiNx.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端工程化/你应该了解比Babel快20-70倍的SWC.md","filePath":"前端工程化/你应该了解比Babel快20-70倍的SWC.md"}'),t={name:"前端工程化/你应该了解比Babel快20-70倍的SWC.md"},n=e(`<h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h2 id="🔥你应该了解的swc-speedy-web-compiler" tabindex="-1">🔥你应该了解的SWC: Speedy Web Compiler <a class="header-anchor" href="#🔥你应该了解的swc-speedy-web-compiler" aria-label="Permalink to &quot;🔥你应该了解的SWC: Speedy Web Compiler&quot;">​</a></h2><p>一提起 Babel 相信大家都不会陌生，你的 <code>javascript compiler</code>，但是自从 <code>Rust</code> 大火以后，前端生态也发生了天翻覆地的变化，我们这次聊的就是重大的变化之一。</p><blockquote><p>一个或许比 Babel 更优的选择</p></blockquote><p>而事实上，很多你所熟知的开源库和框架都在拥抱 <code>SWC</code></p><p>here we go！</p><p>更多信息请移步⬇️ <a href="https://swc.rs/" target="_blank" rel="noreferrer">SWC的官网 https://swc.rs/</a>✅</p><p>⚠️ 阅读本文的前置知识：</p><ul><li><code>AST(Abstract Syntax Tree)</code>：抽象语法树</li><li><code>Compiler pipeline</code>：编译的一个基础工作流（SWC还有一个 <code>minify</code> 的 pipeline）</li><li><code>Node fs system</code>：Node 的文件系统（一丢丢就好）</li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/ce48ebda-3b54-4761-bf5e-8f41dd1258e6" alt="image"></p><h3 id="正文开始👉" tabindex="-1">正文开始👉 <a class="header-anchor" href="#正文开始👉" aria-label="Permalink to &quot;正文开始👉&quot;">​</a></h3><hr><h4 id="什么是-swc-📌" tabindex="-1">什么是 SWC 📌 <a class="header-anchor" href="#什么是-swc-📌" aria-label="Permalink to &quot;什么是 SWC 📌&quot;">​</a></h4><blockquote><p>SWC是一个可扩展的基于Rust的平台，用于下一代快速开发工具。它被Next.js、Parcel和Deno等工具以及Vercel、字节跳动、腾讯、Shopify等公司使用。 SWC可用于编译和打包。在编译方面，它接收使用现代JavaScript特性编写的JavaScript/TypeScript文件，并输出符合所有主流浏览器支持的有效代码。 <strong>SWC is 20x faster than Babel on a single thread and 70x faster on four cores.</strong></p></blockquote><h4 id="开始-📌" tabindex="-1">开始 📌 <a class="header-anchor" href="#开始-📌" aria-label="Permalink to &quot;开始 📌&quot;">​</a></h4><ul><li>先打开 <code>bash</code> 窗口，创建一个项目目录，并用 <code>VSCode</code> 启动项目</li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/4f0b1fde-be4e-4296-acc3-efb7e645fa3b" alt="carbon"></p><ul><li>接着安装依赖 <code>@swc/core</code></li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/716d6d38-988a-4999-9e56-441991ec0a6b" alt="image"></p><ul><li>接着创建 <code>src</code> 目录，并创建 <code>input.js</code>，和 <code>swc.js</code>，创建完成后的目录如下</li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/3351fc21-aac3-49a9-b133-1f1c21b90f20" alt="image"></p><ul><li>然后在 <code>input.js</code> 中输入以下代码，作为后续的源代码</li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/713ebc73-a474-4782-9ff1-9d30507d498c" alt="carbon"></p><ul><li>接着在 <code>swc.js</code> 中输入以下代码，引入的 <code>@swc/core</code> 和 <code>fs</code> 模块</li></ul><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/3bdabb9c-c228-4243-a97d-27add2d9b8d9" alt="carbon"></p><ul><li>接着我们可以先分别感受一下 <code>transform</code> 和 <code>parse</code> 2个过程</li></ul><p><code>parse</code> 添加代码如下：</p><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/fbe0b342-824e-4151-8662-3c495f59d1c8" alt="carbon"></p><p><code>node swc.js</code> 输出如下：</p><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/c9d829e8-5255-460b-be91-e824307e6ecd" alt="image"></p><p>这里我想单独说一下这就是解析出来的 <code>Abstact Syntax Tree</code> ：</p><ul><li><p><strong><code>type: &#39;FunctionDeclaration&#39;</code></strong>：</p><p>表示这是一个函数声明的节点类型。</p></li><li><p><strong><code>identifier: { ... }</code></strong>：</p><p>这是函数声明的标识符，其中包含着名字、起始位置（就是那个 <code>span</code>）等信息。（如果你觉得不够清晰，可以 <code>JSON.stringify(AST, null, 2)</code> 输出看看）</p></li><li><p><strong><code>declare: false</code></strong>：</p><p>表明此函数声明不是一个类型声明。</p></li><li><p><strong><code>params: []</code></strong>：</p><p>表示函数参数为空数组，即此函数没有参数。</p></li><li><p><strong><code>decorators: []</code></strong>：</p><p>函数装饰器列表为空数组，即此函数没有装饰器。</p></li><li><p><strong><code>span: { start: 1, end: 100, ctxt: 3 }</code></strong>：</p><p>表示此函数声明在源代码中所占据的位置范围。</p></li><li><p><strong><code>body: { ... }</code></strong>：</p><p>表函数体其中包着函数的抽语法结构</p></li><li><p><strong><code>generator: false</code></strong>：</p><p>表示此函数不是一个 generator 函数。</p></li><li><p><strong><code>async: false</code></strong>：</p><p>表示此函数不是一个异步函数。</p></li><li><p><strong><code>typeParameters: null</code></strong>：</p><p>表示此函数没有指定类型参数。</p></li><li><p><strong><code>returnType: null</code></strong>：</p><p>表示此函数没有指定返回类型。</p></li></ul><hr><p>okk~ 简单解释了一下 <code>AST</code>，我们继续 ↩️</p><p><code>transform</code> 添加代码如下：</p><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/30fe94f5-06ea-4378-9a0e-38621d820fd1" alt="carbon"></p><p><code>node swc.js</code> 输出如下：</p><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/5a9bd297-43da-4273-baee-c1ef85a84ea8" alt="image"></p><hr><p>⚠️ 这里需要解释一下：</p><blockquote><p><code>SWC</code> 是基于 <code>rust</code> 语言实现的，而且swc团队也希望你用 <code>rust</code>，因为这样会获得更强的性能，所以你想要真正开发插件，请用 <code>rust</code> 语言编写，并参考 swc 的<a href="https://swc.rs/docs/plugin/ecmascript/getting-started" target="_blank" rel="noreferrer">官方文档</a></p></blockquote><p>这篇文章旨在带你感受一下 <code>SWC</code>，主要目的是介绍它：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> swc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@swc/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// transform output code</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transformCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> output</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> swc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isModule: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jsc: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      parser: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        syntax: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ecmascript&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// generate AST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateAST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> swc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    syntax: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ecmascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    comments: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    script: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;es3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isModule: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;src/input.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;utf-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// swc给出的AST和babel并不一样，babel是在estree的标准上加上了自己的东西，就好像oxlint定义了自己的AST标准一样。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 让我觉得奇怪的是swc并没给出类似babel的traverse方法，应该只能通过rust去扩展swc的能力了。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 还是等我N次入门rust之后给大家再继续填坑吧</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果暂时不会rust，那咱们还是用回babel或者acorn,es-walker这些吧</span></span></code></pre></div><p>⛔ 事实上swc的插件贡献者也需要实现visitor去帮你遍历节点，但是仅支持 rust，果然是性能优先，哈哈哈😁。</p><blockquote><p>2023/12/01 patch: 我发现一个库<code>ast-grep</code>如果你还是想用js的话，或许可以试试这个，希望它会有用，不过我没有试过哟，我是看海大佬用来做Vue3的jsx功能。海大佬似乎也是这个库的贡献者，<code>@vue-macros/cli</code>就是基于<code>ast-grep</code>开发的。</p></blockquote><p><img src="https://github.com/newObjectccc/newObjectccc.github.io/assets/42132586/e7655f14-90c8-451b-86dd-e11cbd0fe29d" alt="b88ad5d8c6704d1d4872f389e727fd8"></p><hr><p>😊okk~ 快去尝试为你的团队构建基于 <code>swc</code> 的生态工具吧~ 记得是参考官网用 <code>rust</code> 编写哦~</p>`,48),p=[n];function l(c,h,r,k,o,d){return a(),i("div",null,p)}const b=s(t,[["render",l]]);export{E as __pageData,b as default};
