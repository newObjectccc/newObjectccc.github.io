import{_ as e,c,o,a4 as t}from"./chunks/framework.nQaBHiNx.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端基础/前端基础-可视化变量提升.md","filePath":"前端基础/前端基础-可视化变量提升.md"}'),a={name:"前端基础/前端基础-可视化变量提升.md"},i=t('<h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h2 id="js变量提升" tabindex="-1">Js变量提升 <a class="header-anchor" href="#js变量提升" aria-label="Permalink to &quot;Js变量提升&quot;">​</a></h2><p>这是一篇我自己翻译的前端基础博文，原作者是Lydia Hallie。 想看原文的小伙伴可以直接转到 <a href="https://dev.to/lydiahallie/javascript-visualized-hoisting-478h" target="_blank" rel="noreferrer">🔥🕺🏼 JavaScript Visualized: Hoisting</a></p><p>here we go！</p><h3 id="正文开始👉" tabindex="-1">正文开始👉 <a class="header-anchor" href="#正文开始👉" aria-label="Permalink to &quot;正文开始👉&quot;">​</a></h3><hr><h4 id="🔥🕺🏼-javascript-可视化-变量提升-hoisting" tabindex="-1">🔥🕺🏼 JavaScript 可视化: 变量提升 Hoisting <a class="header-anchor" href="#🔥🕺🏼-javascript-可视化-变量提升-hoisting" aria-label="Permalink to &quot;🔥🕺🏼 JavaScript 可视化: 变量提升 Hoisting&quot;">​</a></h4><p>变量提升（<strong>Hoisting</strong>）是一个每个<code>JavaScript</code>开发人员都听说过的术语，因为当你搜索到一个烦人的错误，并最终在<strong>StackOverflow</strong>网站上所询问的问题时，有人告诉你这个错误是由于变量提升引起的。那么什么是变量提升呢？</p><p>如果你是<code>JavaScript</code>的新手，你可能会遇到“奇怪”的行为，比如一些变量会随机地变成<code>undefined</code>，导致引用错误等等。提升通常被解释为将变量和函数置于文件的顶部，但实际情况并非如此，尽管行为可能看起来像是这样。</p><p>当<code>JavaScript</code>引擎获取到我们的脚本时，它首先要做的是为代码中的数据设置内存。此时不会执行任何代码，只是为执行准备一切。函数声明和变量的存储方式是不同的。函数被存储为函数的引用（也就是指针，指向它的物理内存地址）。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif7.gif" alt="1"></p><p>对于变量，情况有些不同。ES6引入了两个新的关键字来声明变量：<code>let</code>和<code>const</code>。用<code>let</code>或<code>const</code>关键字声明的变量会以未初始化的方式进行存储。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif8.gif" alt="2"></p><p>用<code>var</code>关键字声明的变量被存储为默认值<code>undefined</code></p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif9.gif" alt="3"></p><p>既然创建阶段完成了，我们可以真正执行代码了。让我们看看如果在声明函数或任何变量之前，在文件的顶部有三个<code>console.log</code>语句会发生什么。</p><p>由于函数以对整个函数代码的引用进行存储，我们甚至可以在创建它们的那行代码之前调用它们！🔥</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif10.gif" alt="4"></p><p>当我们在声明之前引用用<code>var</code>关键字声明的变量时，它将简单地返回存储的默认值：<code>undefined</code>！然而，这有时可能会导致“意外”的行为。在大多数情况下，这意味着你无意中引用了它（你可能不希望它实际上具有<code>undefined</code>的值）😬</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif11.gif" alt="5"></p><p>为了防止意外引用一个未定义的变量，就像我们可以用<code>var</code>关键字一样，当我们尝试访问未初始化的变量时，会抛出一个<code>ReferenceError</code>。在它们实际声明之前的“区域”被称为暂时性死区：在初始化之前，你不能引用这些变量（这也包括ES6的类声明！）。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif12.gif" alt="6"></p><p>当引擎执行刀了我们实际声明变量的那一行时，内存中的值会被我们实际声明的值覆盖。</p><p><img src="https://cqrywhcb-test.oss-cn-chengdu.aliyuncs.com/gif13.gif" alt="7"></p><p>全部完成！🎉简单回顾一下：</p><ul><li>在执行代码之前，函数和变量会被存储在内存中的执行上下文中。这就是所谓的变量提升。</li><li>函数储存的是对整个函数的引用，用<code>var</code>关键字声明的变量以<code>undefined</code>的值进行存储，用<code>let</code>和<code>const</code>关键字声明的变量以未初始化的方式进行存储。</li></ul><p>希望通过上面的阅读，变量提升这个术语现在不再那么模糊了。如果你还是觉得不太清楚，不要担心。你在使用它的过程中会变得更加熟悉。随时向我寻求帮助，我很乐意帮助你！😃（<em>不要看我啊，是原作者说她要帮助你！</em>）</p><hr><p>😊okk~ 翻译完了，纯人工翻译，希望能够帮到各位，如有纰漏，欢迎指正~</p>',29),s=[i];function d(r,n,p,l,h,g){return o(),c("div",null,s)}const f=e(a,[["render",d]]);export{u as __pageData,f as default};
